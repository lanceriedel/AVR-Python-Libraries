# This file is automatically generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
from typing import Any, Literal, TypedDict, Union, overload

import paho.mqtt.client as mqtt
from loguru import logger

from .payloads import (
{%- for message in messages %}
    {{ message.name }}Payload,
    _{{ message.name }}Callable,
{%- endfor %}
)
from ..utils.decorators import try_except


# create typed dict of topics associated with callbacks
_MQTTTopicCallable = TypedDict(
    "_MQTTTopicCallable",
    {
{%- for message in messages %}
        "{{ message.topic }}": _{{ message.name }}Callable,
{%- endfor %}
    },
    total=False
)

# create typed dict of topics associated with payloads
_MQTTTopicPayload = TypedDict(
    "_MQTTTopicPayload",
    {
{%- for message in messages %}
        "{{ message.topic }}": {{ message.name }}Payload,
{%- endfor %}
    },
    total=False
)


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    The `topic_map` attribute should be a dictionary of topics to functions
    that will be called with a payload.
    """

    def __init__(self):
        # these should be not be changed
        self.mqtt_host = "mqtt"
        self.mqtt_port = 18830

        # create the MQTT client
        self._mqtt_client = mqtt.Client(protocol=mqtt.MQTTv311)

        # set up the on connect and on message handlers
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: _MQTTTopicCallable = {}

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache: _MQTTTopicPayload = {}

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self._mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self._mqtt_client.loop_start()

    @try_except()
    def on_message(self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage) -> None:
        """
        On message callback, dispatches the message to the appropriate function.
        """
        # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
        if msg.topic in self.topic_map:
            # we talk JSON, no exceptions
            payload = json.loads(msg.payload)
            self.topic_map[msg.topic](payload)

    def on_connect(self, client: mqtt.Client, userdata: Any, flags: dict, rc: int) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

{%- for message in messages %}

    @overload
    def send_message(self, topic: Literal["{{ message.topic }}"], payload: {{ message.name }}Payload) -> None: ...
{%- endfor %}

    def send_message(self, topic: Literal[{% for message in messages %}"{{ message.topic }}"{% if not loop.last %}, {% endif %}{% endfor %}], payload: Union[{% for message in messages %}{{ message.name }}Payload{% if not loop.last %}, {% endif %}{% endfor %}]) -> None:
        """
        Sends a message to the MQTT broker.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")
        self._mqtt_client.publish(topic, json.dumps(payload))
        self.message_cache[topic] = copy.deepcopy(payload)

