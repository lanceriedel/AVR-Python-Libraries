# This file is automatically generated. DO NOT EDIT!
# fmt: off

from __future__ import annotations

import copy
import json
from typing import Any, Literal, overload

import paho.mqtt.client as mqtt
from loguru import logger

from .constants import _MQTTTopicCallableTypedDict, _MQTTTopicPayloadTypedDict
from .payloads import (
{%- for message in messages %}
    {{ message.name }}Payload,
{%- endfor %}
)
from ..utils.decorators import try_except


class MQTTModule:
    """
    Generic MQTT Module class that should be inherited by other modules.
    The `topic_map` attribute should be a dictionary of topics to functions
    that will be called with a payload.
    """

    def __init__(self):
        # these should be not be changed
        self.mqtt_host = "mqtt"
        self.mqtt_port = 18830

        # create the MQTT client
        self._mqtt_client = mqtt.Client(protocol=mqtt.MQTTv311)

        # set up the on connect and on message handlers
        self._mqtt_client.on_connect = self.on_connect
        self._mqtt_client.on_message = self.on_message

        # dictionary of MQTT topics to callback functions
        # this is intended to be overwritten by the child class
        self.topic_map: _MQTTTopicCallableTypedDict = {}

        # maintain a cache of the last message sent on a topic by this module
        self.message_cache: _MQTTTopicPayloadTypedDict = {}

        # record if we were started with loop forever
        self._looped_forever = False

    def run(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run forever
        self._looped_forever = True
        self._mqtt_client.loop_forever()

    def run_non_blocking(self) -> None:
        """
        Class entrypoint. Connects to the MQTT broker and starts the MQTT loop
        in a non-blocking manner.
        """
        # connect the MQTT client
        self._mqtt_client.connect(host=self.mqtt_host, port=self.mqtt_port, keepalive=60)
        # run in background
        self._mqtt_client.loop_start()

    @try_except()
    def on_message(self, client: mqtt.Client, userdata: Any, msg: mqtt.MQTTMessage) -> None:
        """
        On message callback, dispatches the message to the appropriate function.
        """
        # logger.debug(f"Recieved {msg.topic}: {msg.payload}")
        if msg.topic in self.topic_map:
            # we talk JSON, no exceptions
            payload = json.loads(msg.payload)
            self.topic_map[msg.topic](payload)

    def on_connect(self, client: mqtt.Client, userdata: Any, flags: dict, rc: int) -> None:
        """
        On connection callback. Subscribes to MQTT topics in the topic map.
        """
        logger.debug(f"Connected with result {rc}")

        for topic in self.topic_map.keys():
            client.subscribe(topic)
            logger.success(f"Subscribed to: {topic}")

{%- for message in messages %}

    @overload
    def send_message(self, topic: Literal["{{ message.topic }}"], payload: {{ message.name }}Payload, force_write: bool) -> None: ...
{%- endfor %}

    def send_message(self, topic, payload, force_write = False) -> None:
        """
        Sends a message to the MQTT broker. Enabling `force_write` will
        forcefully send the message, bypassing threading mutex. Only use this
        if you know what you're doing.
        """
        # logger.debug(f"Sending message to {topic}: {payload}")
        self._mqtt_client.publish(topic, json.dumps(payload))

        # https://github.com/eclipse/paho.mqtt.python/blob/9782ab81fe7ee3a05e74c7f3e1d03d5611ea4be4/src/paho/mqtt/client.py#L1563
        # pre-emptively write network data while still in a callback, bypassing
        # the thread mutex.
        # can only be used if run with .loop_forever()
        # https://www.bellavrforum.org/t/sending-messages-to-pcc-from-sandbox/311/8
        if self._looped_forever or force_write:
            self._mqtt_client.loop_write()

        self.message_cache[topic] = copy.deepcopy(payload)

